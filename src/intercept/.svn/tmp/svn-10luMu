/*defining _GNU_SOURCE gives access to the RTLD_NEXT variable */
#define _GNU_SOURCE


#include <stdio.h>
#include <stdint.h>
//#include <bits/pthreadtypes.h>
#include <dlfcn.h>
#include <malloc.h>
#include <pthread.h>
#include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <assert.h>
#include <stdbool.h>
#include <execinfo.h>

#include "thread_map.h"
#include "read_file.h"
#include "build_sched.h"
#include "print_trace.h"

/*In normal mode the tool will just run to the end of the schedule and hang
 *In special mode the tool will run to the end of the schedule and then resume normal exectuion
 */
static int FOLLOW_TO_END = 0;
static int FOLLOW_AND_TERMINATE = 0;
static int VERBOSE = 0;
/*RECORD mode is use when their is no schedule*/
static int RECORD_MODE = 0;
/*MONITOR mode is used when their is as schedule and is 
used to prevent the tool from deadlocking.*/
static int MONITOR_MODE = 0;
static int DISABLE = 0;

/*global variables top keep track of thread creation*/
static int current_id = 1;
static int step = 0;

/*global schedule*/
int *schedule;


/*arguments to go to a thread*/
typedef struct {
  void* (*function)(void*);
  int thread_id;
  void* other_args;
} params;


/*mutex and condition variables*/
pthread_mutex_t step_mutex;
pthread_cond_t step_condition;
pthread_mutex_t id_lock;
pthread_mutex_t follow;
pthread_mutex_t nofollow;
pthread_mutex_t end_lock;
pthread_mutex_t terminate_lock;
pthread_mutex_t output_mutex;
pthread_mutex_t follow_lock;



/*Monitor thread used in RECORD mode to trace the progress of the program */
pthread_t monitor_thread;



/*functions to prevent recursive function calls*/
int mutex_lock(pthread_mutex_t*);
int mutex_unlock(pthread_mutex_t*);
int cond_wait(pthread_cond_t*, pthread_mutex_t*);



/*utlity functions*/
void wait();
void step_and_notify();
int schedule_length();
int get_schedule();
void output_schedule();
void check_status();
void set_follow();
int no_follow();
int terminate_set();
void end();
void check_verbose();
void* run_thread(void*);
void update_followed();
void *monitor_progress();

/*check if this is the first call to pthread_create*/
int first_call = 0;





/*************************OVERIDDEN PTHREAD FUNCTIONS***************************/

/*intercepts*/
int pthread_create (pthread_t* thread,
		    __const pthread_attr_t* attr, 
		    void *(*start) (void *), 
		    void *arg) {

  static int (*real_create)(pthread_t * , pthread_attr_t *, void * (*start)(void *), void *) = NULL;
  
  if (!real_create)
    real_create = dlsym(RTLD_NEXT, "pthread_create");
  if(!first_call)
    {
      set_follow();
      check_verbose();
      int got_sched = get_schedule();
      if(!got_sched)
	{
	  fprintf(stderr, "Failed to find the schedule! .... tool will now exit\n");
	  exit(1);
	}
      first_call = 1;
      if(VERBOSE) {
	fprintf(stderr, "Schedule length is: %d\n", schedule_length());
      }
      if(got_sched != 2) {
	fprintf(stderr, "Schedule to be followed:\n");
	output_schedule();
      }
      mutex_lock(&id_lock);
      put_instrumented_id(pthread_self(), 0);
      mutex_unlock(&id_lock);
      if(RECORD_MODE || MONITOR_MODE) {
	fprintf(stderr, "Creating monitor thread ... \n");
	real_create(&monitor_thread, NULL, monitor_progress, NULL);
      }
    }

  /*set up the thread arguments*/
  params* args = malloc(sizeof(params));
  args->thread_id = current_id;
  args->other_args = arg;
  args->function = start;
  current_id++;
  int rc;
  
  if(VERBOSE) {
    printf("Current schedule step: %d\n", schedule[step]);
  }
  
  rc = real_create(thread, NULL, run_thread, args);
  step_and_notify();
  if(!no_follow()) {  
    wait();
  }
  
  return rc;
}


int pthread_join(pthread_t tid, void** value_ptr)
{ 
  int rc;
  static int (*real_join)(pthread_t,void *) = NULL;
  
  if (!real_join)
    real_join = dlsym(RTLD_NEXT, "pthread_join");
  
  if(!no_follow() && !RECORD_MODE) {
    int id = get_instrumented_id(tid);
    if(VERBOSE) {
      fprintf(stderr, "Waiting for thread %d to join!\n", id);
    }
    step_and_notify();
    wait();

    int res = pthread_tryjoin_np(tid,value_ptr);
    if(res != EBUSY)
      {
	return res;
      }
    
    step_and_notify();
    wait();

    res = pthread_tryjoin_np(tid,value_ptr);
    if(res != EBUSY)
      {
	return res;
      }

    step_and_notify();
    wait();
    res = pthread_tryjoin_np(tid, value_ptr);
    if(res != EBUSY) {
      return res;
    }

    return pthread_tryjoin_np(tid, value_ptr);
  } else {
    step_and_notify();
    rc = real_join(tid, value_ptr);
    return rc;
  }
}

int pthread_mutex_lock(pthread_mutex_t *mutex)
{


  /*DISABLE flag is used only for debugging purposes and printing stack traces.*/
  if(DISABLE)
    {
      return mutex_lock(mutex);
    }

  int res;
  if(!no_follow() && !RECORD_MODE){
    int id = get_instrumented_id(pthread_self());
    if(VERBOSE) {
    fprintf(stderr, "Thread with id: %d trying to lock mutex, schedule[%d], step:%d\n",
	    id, schedule[step], step);
    }

    /*Check that we have not reached the end of the schedule yet and if we have then use the normal
     pthread mutex lock. These check are scattered all throughout the function.*/
    if(no_follow()) {
      return mutex_lock(mutex);
    }

    step_and_notify(); 
    wait();
    if(pthread_mutex_trylock(mutex))
      {
	if(no_follow()) {
	  return mutex_lock(mutex);
	}
	if(VERBOSE) {
	  fprintf(stderr, "Thread: %d obtained the mutex\n", id);
	}
	return 1;
      } 


     if(no_follow()) {
       return mutex_lock(mutex);
     }


     step_and_notify();  
     wait();


     if(pthread_mutex_trylock(mutex))
       {
	 if(no_follow()) {
	  return mutex_lock(mutex);
	}
	if(VERBOSE) {
	  fprintf(stderr, "Thread: %d obtained the mutex\n", id);
	}
	if(no_follow()) {
	  return mutex_lock(mutex);
	}
	if(VERBOSE) {
	  fprintf(stderr, "Thread: %d obtained the mutex\n", id);
	}
	return 1;
      } 


     if(no_follow()) {
       return mutex_lock(mutex);
     }


     step_and_notify();  
     my_wait();


     if(pthread_mutex_trylock(mutex))
       {
	 if(no_follow()) {
	  return mutex_lock(mutex);
	}
	if(VERBOSE) {
	  fprintf(stderr, "Thread: %d obtained the mutex\n", id);
	}
	return 1;
      }
     //assert(false);
  } else {
    /*step and notify used here for recording purposes.*/
    step_and_notify();
    res = mutex_lock(mutex);
    return res;
  }
}


int pthread_mutex_unlock(pthread_mutex_t* mutex)
{
  int id = get_instrumented_id(pthread_self());
  if(DISABLE)
    {
      return mutex_unlock(mutex);
    }
  if(!no_follow() && !RECORD_MODE) {
    step_and_notify();
    my_wait();

    
    if(VERBOSE) {
      fprintf(stderr, "Thread %d unlocking mutex schedule[%d] and step:%d\n",
	      id, schedule[step], step);
    }
    int res = mutex_unlock(mutex);
    return res;
  } else {
    /*step and notify used here for recording purpose only.*/
    step_and_notify();
    return mutex_unlock(mutex);
  }
}

int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex)
{
  if(VERBOSE) {
    fprintf(stderr, "Thread %d waiting on condition....\n", get_instrumented_id(pthread_self()));
  }
  if(!no_follow() && !RECORD_MODE) {
    mutex_unlock(mutex);
    step_and_notify();
    wait();
    mutex_lock(mutex);
  } else {
    /*step and notify used here for recording purposes only.*/
    step_and_notify();
    return cond_wait(cond, mutex);
  }
  return 1;
}

int pthread_cond_timedwait(pthread_cond_t *__restrict cond,
			   pthread_mutex_t *__restrict mutex,
			   __const struct timespec *__restrict
			  abstime) {
  if(!no_follow() && !RECORD_MODE) {
    pthread_mutex_lock(mutex);
    pthread_mutex_unlock(mutex);
    return ETIMEDOUT;
  } else {
    step_and_notify();
    static int(*real_timed)(pthread_cond_t *__restrict __cond,
			   pthread_mutex_t *__restrict __mutex,
			   __const struct timespec *__restrict
			    __abstime) = NULL;
    real_timed = dlvsym(RTLD_NEXT, "pthread_cond_timedwait", "GLIBC_2.3.2");
    return real_timed(cond, mutex, NULL);
  }
}


/*******************************ORIGINAL API FUNCTIONS*************************/



int mutex_lock(pthread_mutex_t* mutex)
{
  static int(*real_lock)(pthread_mutex_t*) = NULL;
  real_lock = dlsym(RTLD_NEXT, "pthread_mutex_lock");
  int res = real_lock(mutex);
  return res;
}

int mutex_unlock(pthread_mutex_t* mutex)
{
  static int(*real_unlock)(pthread_mutex_t* mutex) = NULL;
  real_unlock = dlsym(RTLD_NEXT, "pthread_mutex_unlock");
  int res = real_unlock(mutex);
  return res;
}

int cond_wait(pthread_cond_t* cond, pthread_mutex_t* mut)
{

  static int(*real_wait)(pthread_cond_t*, pthread_mutex_t*) = NULL;

  /*use dlvsym() to prevent the cond variable passed back from being changed to an outdated version*/
  real_wait = dlvsym(RTLD_NEXT, "pthread_cond_wait", "GLIBC_2.3.2");
  int res = real_wait(cond, mut);
  return res;
}








/*********************************RUN THREAD*******************************/

/*intercept pthread_create*/
void* run_thread(void* arg) {

  params* args = (params*) arg;
  mutex_lock(&id_lock);
  put_instrumented_id(pthread_self(), args->thread_id);
  mutex_unlock(&id_lock);
  if(!no_follow()) {  
    my_wait();
    if(VERBOSE) {
      fprintf(stderr, "About to run thread %d...\n\n", args->thread_id);
    }
  }
  void* result = args->function((void*)args->other_args);
  step_and_notify();
  wait();
  step_and_notify();
  return result;
}





/*********************UTILITY FUNCTIONS***********************************/

/*wait*/
void my_wait()
{
 
  /*If in RECORD mode the tool should not be in here anyway*/
  if(RECORD_MODE) {
    return;
  }
 
  int thread_id = get_instrumented_id(pthread_self());
  if(!no_follow()) {
    mutex_lock(&step_mutex);
    while(thread_id != schedule[step])
      {
	if(VERBOSE) {
	  if(no_follow()) {
	    mutex_unlock(&step_mutex);
	    return;
	  }
	  if(terminate_set()) 
	    { 
	      end(); 
	    }
	  fprintf(stderr, "Thread %d sleeping ... schedule[%d], step:%d\n", 
		  thread_id, schedule[step], step);
	}
	cond_wait(&step_condition, &step_mutex);
      }
  }
}


/*step and notify()*/
void step_and_notify()
{
  mutex_lock(&step_mutex);
  step++;
  //print_trace();
  update_followed();
  pthread_cond_broadcast(&step_condition);
  mutex_unlock(&step_mutex);
}

/*get the length of the passed schedule*/
int schedule_length()
{

  int *p = schedule;
  int count = 0;
  while(*p != INT_MAX)
    {
      count++;
      p++;
    }

 
  return count;
}


/*gets and set the schedule*/
int get_schedule() 
{
  char* env = getenv("KLEE_SCHED");

  schedule = get_vector(env);

  if(schedule)
    return 1;
  else if(!schedule && RECORD_MODE) 
    return 2;
  else
    return 0;

}

/*print the schedule*/
void output_schedule()
{
  printf("[");
  int i;
  for(i = 0; i < schedule_length(); ++i)
    {
      printf("%d ", schedule[i]);
    }
  printf("]\n");
}


/*check the status of the follow environment variable to determine what mode the tool should be
  run in*/
void set_follow()
{
  char* val = getenv("FOLLOW_TO_END");
  char* fval = getenv("FOLLOW_AND_TERMINATE");
  char* rval = getenv("RECORD_MODE");
  char* mval = getenv("MONITOR_MODE");
  if(!val && !fval && !rval && !mval)
    {
      return;
    }
  else if(val)
    {
      mutex_lock(&end_lock);
      FOLLOW_TO_END = 1;
      mutex_unlock(&end_lock);
      if(VERBOSE) {
	fprintf(stderr, "FOLLOW_TO_END flag is active\n");
      }
    } 
  else if(fval)
    {
      mutex_lock(&terminate_lock);
      FOLLOW_AND_TERMINATE = 1;
      mutex_unlock(&terminate_lock);
      if(VERBOSE) {
	fprintf(stderr, "FOLLOW_AND_TERMINATE flag is active\n");
      }
    }
  else if(rval) {
    mutex_lock(&end_lock);
    RECORD_MODE = 1;
    mutex_unlock(&end_lock);
    if(VERBOSE) {
      fprintf(stderr, "RECORD flag set\n");
    }
  } 
  if(mval){
    mutex_lock(&end_lock);
    MONITOR_MODE = 1;
    mutex_unlock(&end_lock);
    if(VERBOSE) {
      fprintf(stderr, "MONITOR flag set\n");
    }
  }
}

/*check flag and step*/
int spoken = 0;
int no_follow()
{

  if(FOLLOW_TO_END && step >= schedule_length()) {
    if(!spoken) {
      fprintf(stderr, "Program has run to the end of the schedule and is resuming normal execution ...\n");
      spoken++;
    }
    return 1;
  }
  return 0;
}
/*check is VERBOSE mode is active*/
void check_verbose()
{
  char* v = getenv("KLEE_VERBOSE_MODE");
  if(!v)
    {
      return;
    }
  else if(v)
    {
      VERBOSE = 1;
      fprintf(stderr, "Running in verbose mode..................\n");
    }
}

int terminate_set() {
  if(FOLLOW_AND_TERMINATE && step >= schedule_length()) {
    return 1;
  }
  return 0;
}

void end() {
  fprintf(stderr, "The program has run to the end of the schedule: ");
  mutex_lock(&output_mutex);
  output_schedule();
  mutex_unlock(&output_mutex);
  fprintf(stderr, "A bug was found at the end of this schedule at step: %d\n",
	  step);
  mutex_lock(&output_mutex);
  print_followed();
  mutex_unlock(&output_mutex);
  //exit code 4 for matching schedules
  if(schedules_matched(schedule, schedule_length())) {
    exit(4);
  } else {
    //exit code 3 for failure to follow passed schedule
    exit(3);
  }
} 

/*update_followed*/
void update_followed() {
  mutex_lock(&follow_lock);
  add_to_followed(get_instrumented_id(pthread_self()));
  mutex_unlock(&follow_lock);
}

/*monitor thread to check satisfactory progress*/
void* monitor_progress() {
  int last_step = step;
  while(true) {
    sleep(2);
    if(last_step == step) {
      /*if there has been no change after execution, assume satisfactory progress has
	not been made and report a deadlock*/
      fprintf(stderr, "\n\nPotential deadlock detected!\nTool will now exit with error code: %d\n\n",
	      5);
      print_followed();
      write_to_file();

      exit(5);
    } else {
      last_step = step;
    }
  }
}

