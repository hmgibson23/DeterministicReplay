{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset128 Times New Roman;}{\f4\fswiss\fprq2\fcharset128 Arial;}{\f5\fnil\fprq2\fcharset128 AR PL UMing HK;}{\f6\fnil\fprq2\fcharset128 Lohit Hindi;}{\f7\fnil\fprq0\fcharset128 Lohit Hindi;}}
{\colortbl;\red0\green0\blue0;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\kerning1\hich\af5\langfe2052\dbch\af6\afs24\lang1081\loch\f3\fs24\lang2057 Normal;}
{\s15\sbasedon0\snext16\sb240\sa120\keepn\hich\af5\dbch\af6\afs28\loch\f4\fs28 Heading;}
{\s16\sbasedon0\snext16\sb0\sa120 Text body;}
{\s17\sbasedon16\snext17\sb0\sa120\dbch\af7 List;}
{\s18\sbasedon0\snext18\sb120\sa120\noline\i\dbch\af7\afs24\ai\fs24 Caption;}
{\s19\sbasedon0\snext19\noline\dbch\af7 Index;}
}{\info{\author Hugo Gibson}{\creatim\yr2012\mo8\dy20\hr9\min9}{\revtim\yr0\mo0\dy0\hr0\min0}{\printim\yr0\mo0\dy0\hr0\min0}{\comment LibreOffice}{\vern3300}}\deftab709

{\*\pgdsctbl
{\pgdsc0\pgdscuse195\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\pgdscnxt0 Default;}
{\pgdsc1\pgdscuse195\pgndec\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn567\pgdscnxt1 HTML;}}
\formshade\paperh16838\paperw11906\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn11906\pghsxn16838\marglsxn1134\margrsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Future Work:}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
The most obvious extension to the tool is to continue implementing the rest of the Pthreads API. While it is a large API, we think implementing the whole API is feasible and would result in a robust and reliable tool that could be used with all concurrent C programs that use the Pthreads API to provide deterministic replay. In combination with KLEE-THREADS, this would a create a full record/replay suite to concurrent C programs and would prove an invaluable tool to developers developing concurrent software in C.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Another possible extension to the tool would be to give a more thorough execution trace to the bug. In the its current state, the tool does not really provide too in-depth a trace after termination to the bug. So as an added, extension it would be desirable to provide the user with a stack trace or clear path to the fault after the program's termination. }
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Also when the tool runs in its default execution state, it simply hangs on once it reaches the end of a schedule and this is somewhat unhelpful for users of the tool who might want to print a stack trace to help determine the state of variables at the program's termination. To this end, we think it would desirable to work towards integrating the tool with an existing debugger such as gdb. This would be highly desirable since it would provide the programmer with the ability to trace concurrency bugs but also to use all of the tools that gdb provides as well.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
The final extension which we considered but did not have time to implement was extending the tool's record feature to make it more robust in programs that have data races. In its current state the record mode will detect a deadlock and output the schedule that to that deadlock. The schedule it produces will not always be accurate if the program has data races, since by their very nature the specific thread ordering of data races is difficult to trace. The tool will only offer a trace to data races if the variable is protected by a mutex or a condition variable. Variables that are not protected by the Pthreads API will be ignored, since the tool will only log the thread ordering if a thread calls the step_and_notify() function.  If a data race occurs with no synchronisation then the tool will not notice it and the trace it produced might not accurately represent the actual schedule of execution. Fixing this would be a desirable extension to the tool.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
KLEE-THREADS:}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
KLEE-THREADS uses dynamic symbolic execution to detect data races in concurrent C programs. wet is built on top of the KLEE symbolic virtual machine. KLEE is capable of automatically generating tests that achieve high coverage of complex programs \\cite\{KLEE\}.KLEE uses the LLVM instruction set to map instructions to constraints without approximation and to execute the program within its framework. KLEE uses symbolic execution on a set of generated states to select and execute a wide variety of execution paths. KLEE handles non-determinism by modelling the native execution environment symbolically. This enables KLEE to consider multiple paths under a variety of situations, allowing it to model the non-deterministic state.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
After KLEE-THREADS has found a bug it will produce a thread schedule that led to that bug and continue its execution to find more bugs. A typical thread schedule that KLEE-THREADS produces will instrument the main thread as 0 and instruments each created thread as 1,2,3 etc. An example schedule might look as follows: [0,0,0,1,1,2,2,3,2,2,1], with the end of the schedule leading to a bug. KLEE-THREADS will typically output a large number of schedules for any given executable. If a program is particularly large, it is possible to pass KLEE arguments to restrict the amount of schedules produced and also to alter what sort of schedules it produces. For example, we can force KLEE-THREADS to output longer schedules that might lead to very specific trace occurring. This can be useful to the user since it allows them to track down specific bugs.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
KLEE supports symbolic implementation of many POSIX functions so many programs using POSIX-compliant software can run in KLEE without having to recompile or instrument them. This is a nice match to our tool which similarly requires no recompilation or re-linking of executables it is passed.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Our tool was originally conceived as an extension to KLEE-THREADS that would provide deterministic replay using the schedules that KLEE-THREADS output. For this reason, the schedules which out tool follows are similar in design to those output by KLEE-THREADS \uc3 \u8211\'e2\'80\'93 that is, the main is 0 and is thread created is instrumented as 1,2,3 etc. Nevertheless, our tool will work independently of KLEE-THREADS but is works excellently with schedules that KLEE-THREADS produces.\uc1 }
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Being built on top of the KLEE symbolic virtual machine enables KLEE-THREADS to very wide search space and produce many more schedules than typical replay tools. This is a major advantage, given the amount of concurrency bugs it can find in a given program after just one symbolic trace.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Amendment to dining philosophers schedule:}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
Since the tool does not perform well in its record mode if there are data races present, we wrote a short program which is has data races and leads to deadlocks. }
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
An example of a program that could result in an inaccurate trace is shown below:}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
As you can see, the global variable I is not protected by a mutex and therefore read and write access to I will not be placed into the schedule by the tool. This may result in a schedule the tool outputs not actually leading to a deadlock since the value of the variable I might be different at the end of the schedule.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
For this reason out tool is effective at tracing deadlocks that are not dependent on the value of some global variable which has a data race in it, since such programs will result in an accurate execution schedule. If a program has unguarded shared variables, then our tool will not be able to pick them up since it only overrides the Pthreads API and is not designed to trace data races using traditional static or dynamic analysis techniques.}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
The tool's success in the both of the above programs is a result of there being a clear synchronisation trace for each program. In each program the threads call the }
\par \pard\plain \s16\sb0\sa120\li0\ri0\lin0\rin0\fi0\sb0\sa0{\rtlch \ltrch\loch
}
\par }